/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules;

import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrServer;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.client.solrj.response.SolrPingResponse;
import org.apache.solr.client.solrj.response.UpdateResponse;
import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.annotations.*;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.annotations.param.Payload;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.MalformedURLException;
import java.util.Collection;
import java.util.List;


/**
 * Module for Apache Solr Integration, it is based on the SolrJ Java Client API and allows interaction
 * with Apache Solr standalone servers.
 *
 * @author Juan Alberto LÃ³pez Cavallotti
 */

@Connector(name = "solr", schemaVersion = "1.0.0-SNAPSHOT", friendlyName = "Solr", minMuleVersion = "3.3.0")
public class SolrConnector {

    private static final Logger logger = LoggerFactory.getLogger(SolrConnector.class);

    //the SolrServer connection
    private SolrServer server;

    /**
     * The URL of the Solr server to connect to. To define the solr core to use, specify it here, otherwise the default
     * core will be used.
     */
    @Configurable
    @Optional
    @Default("http://localhost:8983/solr")
    private String serverUrl;

    /**
     * Connect to the Solr Server using commons http client gateway.
     */
    @Connect
    public synchronized void connect() throws ConnectionException {
        try {
            server = new CommonsHttpSolrServer(serverUrl);
        } catch (MalformedURLException ex) {
            logger.error("The url: " + serverUrl + " is malformed.");
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, ex.getMessage(), "Url is not properly written", ex);
        } catch (Exception ex) {
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, ex.getMessage(), "Could not connect to solr", ex);
        }
    }

    /**
     * Identify the connection.
     *
     * @return null, not used at this time.
     */
    @ConnectionIdentifier
    public String connectionIdentifier() {
        return null;
    }

    /**
     * Disconnect from the server, nothing special needed at this time.
     */
    @Disconnect
    public synchronized void disconnect() {
        if (server == null) {
            return;
        }
        //do something to disconnect.
        server = null;
    }

    /**
     * Validate the connection by sending a ping request.
     *
     * @return true if the ping call succeeds, false otherwise.
     */
    @ValidateConnection
    public boolean isConnected() {
        if (server == null) {
            return false;
        }

        try {
            SolrPingResponse response = server.ping();

            if (logger.isDebugEnabled()) {
                logger.debug("Pinged the server, response time is: " + response.getQTime());
            }

            if (response.getQTime() > 0) {
                return true;
            }

        } catch (Exception ex) {
            logger.error("Got exception while trying to Ping Server", ex);
            return false;
        }
        //default answer
        return false;
    }

    /**
     * Submit a query to the server and get the results.
     * <p/>
     * {@sample.xml ../../../doc/solr-connector.xml.sample solr:query}
     *
     * @param q       this is the query string called 'q' using solr's nomenclature, normally this has the form of
     *                <em>field</em>:<em>value</em> or just <em>value</em> for querying the default field. Please take a look
     *                at solr's documentation for info on how to write queries.
     * @param handler which handler to use when querying.
     * @param highlightField The field on which to highlight search results.
     * @param highlightSnippets The number of highlight snippets per result.
     * @param facetFields A list of fields for a faceted query. If not null, will enable faceted search.
     * @param facetLimit The facet limit of the query.
     * @param facetMinCount The facet minimum count of the query.
     * @return a {@link QueryResponse QueryResponse} object with the search results.
     * @throws SolrModuleException This exception wraps exceptions thrown when querying the server fails.
     */
    @Processor
    public QueryResponse query(String q,
                               @Optional @Default("/select") String handler,
                               @Optional String highlightField,
                               @Optional @Default("1") int highlightSnippets,
                               @Optional List<String> facetFields,
                               @Optional @Default("8") int facetLimit,
                               @Optional @Default("1") int facetMinCount) throws SolrModuleException {

        SolrQuery query = new SolrQuery(q);
        query.setQueryType(handler);

        applyHighlightingLogic(query, highlightField, highlightSnippets);
        applyFacetingLogic(query, facetFields, facetLimit, facetMinCount);

        try {

            return server.query(query);

        } catch (SolrServerException ex) {
            logger.error("Got server exception while trying to query", ex);
            throw new SolrModuleException("Got server exception while trying to query", ex);
        }
    }

    private void applyFacetingLogic(SolrQuery query, List<String> facetFields, int facetLimit, int facetMinCount) {
        if (facetFields == null || facetFields.isEmpty()) {
            logger.debug("Faceting is disabled for this query...");
            return;
        }

        query.setFacet(true);
        query.setFacetLimit(facetLimit);
        query.setFacetMinCount(facetMinCount);
        query.addFacetField(facetFields.toArray(new String[0]));
    }

    private void applyHighlightingLogic(SolrQuery query, String highlightField, int highlightSnippets) {

        if (highlightField == null) {
            logger.debug("Highlighting is disabled for this query...");
            return;
        }

        query.setHighlight(true);
        query.setHighlightSnippets(highlightSnippets);
        query.setParam("hl.fl", highlightField);
    }

    /**
     * Delete elements by specifying a query, if you wish to delete everything use <em>*:*</em> as the query parameter.
     *
     * {@sample.xml ../../../doc/solr-connector.xml.sample solr:delete-by-query}
     *
     * @param q the query of which results will be deleted.
     * @return the server response object.
     * @throws SolrModuleException This exception wraps the exceptions thrown by the client.
     */
    @Processor
    public UpdateResponse deleteByQuery(String q) throws SolrModuleException {
        try {
            return server.deleteByQuery(q);
        } catch (SolrServerException ex) {
            throw new SolrModuleException("Got Server exception while deleting by query", ex);
        } catch (IOException ex) {
            throw new SolrModuleException("Got IOException while deleting by query", ex);
        }
    }


    /**
     * Delete a specific element on the index by ID.
     *
     * {@sample.xml ../../../doc/solr-connector.xml.sample solr:delete-by-id}
     *
     * @param id the ID of the element to delete.
     * @return the server response object.
     * @throws SolrModuleException This exception wraps the exceptions thrown by the client.
     */
    @Processor
    public UpdateResponse deleteById(String id) throws SolrModuleException {

        try {
            return server.deleteById(id);
        } catch (SolrServerException ex) {
            throw new SolrModuleException("Got Server exception while deleting by ID", ex);
        } catch (IOException ex) {
            throw new SolrModuleException("Got IOException while deleting by ID", ex);
        }
    }


    /**
     * Index a simple pojo or a collection of pojo's and then, if everything goes well, commit the results to solr.
     * {@sample.xml ../../../doc/solr-connector.xml.sample solr:index-pojo}
     * @param payload The pojo or collection of pojos to send to the solr server.
     * @return the API response when commiting the update.
     * @throws SolrModuleException This exception wraps exceptions thrown by the client.
     */
    @Processor
    public UpdateResponse indexPojo(@Payload Object payload) throws SolrModuleException {


        if (payload == null) {
            logger.debug("Ignored request to index a Null Pojo");
            return null;
        }

        boolean isCollection = payload instanceof Collection;

        try {

            if (isCollection) {

                if (logger.isDebugEnabled()) logger.debug("Indexing beans collection ...");
                server.addBeans((Collection) payload);

            } else {
                if (logger.isDebugEnabled()) logger.debug("Indexing a simple pojo ...");
                server.addBean(payload);
            }

            return server.commit();

        } catch (SolrServerException ex) {
            rollbackUpdates("Got server error while trying to index pojo(s)", ex);
            return null; //unreachable but the compiler complains :)
        } catch (IOException ex) {
            rollbackUpdates("Got IOException while trying to index pojo(s) ", ex);
            return null; //unreachable but the compiler complains :)
        }
    }


    private void rollbackUpdates(String message, Exception cause) throws SolrModuleException {
        try {
            logger.error(message, cause);
            server.rollback();
            throw new SolrModuleException(message, cause);
        } catch (Exception ex) {
            message = "Could not rollback an update";
            logger.error(message, ex);
            throw new SolrModuleException(message, ex);
        }
    }

    public String getServerUrl() {
        return serverUrl;
    }

    public void setServerUrl(String serverUrl) {
        this.serverUrl = serverUrl;
    }
}
